use crate::{metrics, NotificationProcessor};
use anyhow::Context;
use subvt_types::app::{Network, NotificationPeriodType};
use subvt_types::subvt::NetworkStatus;

impl NotificationProcessor {
    /// Subscribes to the network status notifications from Redis (which are generated by
    /// `subvt-network-status-updater`) and processes epoch and era notification at epoch
    /// and era changes.
    pub(crate) async fn start_era_and_epoch_notification_processor(
        &self,
        network: &Network,
    ) -> anyhow::Result<()> {
        log::info!(
            "Start era/epoch notification processor for {}.",
            network.name,
        );
        let redis_url = network
            .redis_url
            .as_ref()
            .unwrap_or_else(|| panic!("{} Redis URL is missing.", network.name));
        let redis = redis::Client::open(redis_url.as_str()).context(format!(
            "Cannot connect to {} Redis at URL {}.",
            network.name, redis_url,
        ))?;
        let mut data_connection = redis.get_connection()?;
        let mut pub_sub_connection = redis.get_connection()?;
        let mut active_era_index = 0;
        let mut current_epoch_index = 0;
        let mut pub_sub = pub_sub_connection.as_pubsub();
        pub_sub.subscribe(format!(
            "subvt:{}:network_status:publish:best_block_number",
            network.name.to_lowercase(),
        ))?;
        loop {
            let _ = pub_sub.get_message();
            let key = format!("subvt:{}:network_status", network.name.to_lowercase());
            let status_json_string: String =
                redis::cmd("GET").arg(key).query(&mut data_connection)?;
            let status: NetworkStatus = serde_json::from_str(&status_json_string)?;
            log::info!(
                "New {} status, best block #{}.",
                network.name,
                status.best_block_number,
            );
            // process epoch notifications if epoch has changed
            if current_epoch_index != status.current_epoch.index {
                log::info!(
                    "New {} epoch #{}. Check for notifications.",
                    network.name,
                    status.current_epoch.index,
                );
                match self
                    .process_notifications(
                        Some(network.id),
                        NotificationPeriodType::Epoch,
                        status.current_epoch.index as u32,
                    )
                    .await
                {
                    Ok(_) => {
                        metrics::epoch_index().set(status.current_epoch.index as i64);
                    }
                    Err(error) => {
                        log::error!(
                            "Error while processing {} epoch #{} notifications: {:?}",
                            network.name,
                            status.current_epoch.index,
                            error,
                        );
                    }
                }

                current_epoch_index = status.current_epoch.index;
            }
            // process era notifications if epoch has changed
            if active_era_index != status.active_era.index {
                log::info!(
                    "New {} era #{}. Check for notifications.",
                    network.name,
                    status.active_era.index,
                );
                match self
                    .process_notifications(
                        Some(network.id),
                        NotificationPeriodType::Era,
                        status.active_era.index,
                    )
                    .await
                {
                    Ok(_) => {
                        metrics::era_index().set(status.active_era.index as i64);
                    }
                    Err(error) => {
                        log::error!(
                            "Error while processing era #{} notifications: {:?}",
                            status.active_era.index,
                            error,
                        );
                    }
                }
                active_era_index = status.active_era.index;
            }
        }
    }
}
