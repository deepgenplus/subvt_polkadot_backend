use crate::{NotificationProcessor, CONFIG};
use log::{error, info};
use subvt_types::app::NotificationPeriodType;
use subvt_types::subvt::NetworkStatus;

impl NotificationProcessor {
    /// Subscribes to the network status notifications from Redis (which are generated by
    /// `subvt-network-status-updater`) and processes epoch and era notification at epoch
    /// and era changes.
    pub(crate) async fn start_era_and_epoch_notification_processor(&self) -> anyhow::Result<()> {
        info!("Start era/epoch notification processor.");
        let mut data_connection = self.redis.get_connection()?;
        let mut pub_sub_connection = self.redis.get_connection()?;
        let mut active_era_index = 0;
        let mut current_epoch_index = 0;
        let mut pub_sub = pub_sub_connection.as_pubsub();
        pub_sub
            .subscribe(format!(
                "subvt:{}:network_status:publish:best_block_number",
                CONFIG.substrate.chain
            ))
            .unwrap();
        loop {
            let _ = pub_sub.get_message();
            let key = format!("subvt:{}:network_status", CONFIG.substrate.chain);
            let status_json_string: String = redis::cmd("GET")
                .arg(key)
                .query(&mut data_connection)
                .unwrap();
            let status: NetworkStatus = serde_json::from_str(&status_json_string).unwrap();
            // process epoch notifications if epoch has changed
            if current_epoch_index != status.current_epoch.index {
                info!(
                    "New epoch #{}. Check for notifications.",
                    current_epoch_index
                );
                if let Err(error) = self
                    .process_notifications(
                        NotificationPeriodType::Epoch,
                        current_epoch_index as u32,
                    )
                    .await
                {
                    error!(
                        "Error while processing epoch #{} notifications: {:?}",
                        current_epoch_index, error
                    );
                }
                current_epoch_index = status.current_epoch.index;
            }
            // process era notifications if epoch has changed
            if active_era_index != status.active_era.index {
                info!("New era #{}. Check for notifications.", active_era_index);
                if let Err(error) = self
                    .process_notifications(NotificationPeriodType::Era, active_era_index)
                    .await
                {
                    error!(
                        "Error while processing era #{} notifications: {:?}",
                        active_era_index, error
                    );
                }
                active_era_index = status.active_era.index;
            }
        }
    }
}
