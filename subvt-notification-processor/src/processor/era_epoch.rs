use crate::{metrics, NotificationProcessor, CONFIG};
use anyhow::Context;
use futures_util::StreamExt as _;
use std::str::FromStr;
use subvt_types::app::{Network, NotificationPeriodType};
use subvt_types::substrate::Chain;
use subvt_types::subvt::NetworkStatus;

impl NotificationProcessor {
    /// Subscribes to the network status notifications from Redis (which are generated by
    /// `subvt-network-status-updater`) and processes epoch and era notification at epoch
    /// and era changes.
    pub(crate) async fn start_era_and_epoch_notification_processor(
        &self,
        network: &Network,
    ) -> anyhow::Result<()> {
        log::info!(
            "Start era/epoch notification processor for {}.",
            network.display,
        );
        let redis_url = match Chain::from_str(&network.chain)? {
            Chain::Kusama => &CONFIG.redis.kusama_url,
            Chain::Polkadot => &CONFIG.redis.polkadot_url,
            Chain::Westend => &CONFIG.redis.westend_url,
        };
        let redis = redis::Client::open(redis_url.as_str()).context(format!(
            "Cannot connect to {} Redis at URL {}.",
            network.display, redis_url,
        ))?;
        let mut data_connection = redis.get_async_connection().await?;
        let mut pubsub_connection = redis.get_async_connection().await?.into_pubsub();
        let mut active_era_index = 0;
        let mut current_epoch_index = 0;
        pubsub_connection
            .subscribe(format!(
                "subvt:{}:network_status:publish:best_block_number",
                network.display.to_lowercase(),
            ))
            .await?;
        let mut pubsub_stream = pubsub_connection.on_message();
        loop {
            let _ = pubsub_stream.next().await;
            let key = format!("subvt:{}:network_status", network.display.to_lowercase());
            let status_json_string: String = redis::cmd("GET")
                .arg(key)
                .query_async(&mut data_connection)
                .await?;
            let status: NetworkStatus = serde_json::from_str(&status_json_string)?;
            log::info!(
                "New {} status, best block #{}.",
                network.display,
                status.best_block_number,
            );
            // process epoch notifications if epoch has changed
            if current_epoch_index != status.current_epoch.index {
                log::info!(
                    "New {} epoch #{}. Check for notifications.",
                    network.display,
                    status.current_epoch.index,
                );
                match self
                    .process_notifications(
                        Some(network.id),
                        NotificationPeriodType::Epoch,
                        status.current_epoch.index as u32,
                    )
                    .await
                {
                    Ok(_) => {
                        metrics::epoch_index().set(status.current_epoch.index as i64);
                    }
                    Err(error) => {
                        log::error!(
                            "Error while processing {} epoch #{} notifications: {:?}",
                            network.display,
                            status.current_epoch.index,
                            error,
                        );
                    }
                }

                current_epoch_index = status.current_epoch.index;
            }
            // process era notifications if epoch has changed
            if active_era_index != status.active_era.index {
                log::info!(
                    "New {} era #{}. Check for notifications.",
                    network.display,
                    status.active_era.index,
                );
                match self
                    .process_notifications(
                        Some(network.id),
                        NotificationPeriodType::Era,
                        status.active_era.index,
                    )
                    .await
                {
                    Ok(_) => {
                        metrics::era_index().set(status.active_era.index as i64);
                    }
                    Err(error) => {
                        log::error!(
                            "Error while processing era #{} notifications: {:?}",
                            status.active_era.index,
                            error,
                        );
                    }
                }
                active_era_index = status.active_era.index;
            }
        }
    }
}
